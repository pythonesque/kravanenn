use coq::checker::closure::{
    RedError,
    RedResult,
};
use coq::checker::environ::{
    ConstEvaluationResult,
    Env,
    EnvError,
    Globals,
    Stratification,
};
use coq::checker::inductive::{
    CaseError,
    CaseResult,
    IndError,
    IndEvaluationError,
    IndEvaluationResult,
};
use coq::checker::reduction::{
    ConvError,
    SpecialRedError,
};
use coq::checker::term::{
    DecomposeNError,
    extended_rel_list,
};
use coq::checker::type_errors::{
    TypeError,
};
use coq::checker::univ::{
    Huniv,
    SubstError,
    UnivError,
    UndoLog,
    UnivConstraintError,
};
use coq::kernel::esubst::{
    Idx,
    IdxError,
    IdxResult,
};
use coq::kernel::names::{
    MutInd,
};
use coq::lib::rtree::{
    RTreeError,
};
use core::nonzero::{NonZero};
use ocaml::de::{
    ORef,
    Str,
};
use ocaml::values::{
    Cst,
    Constr,
    ConstraintType,
    Engagement,
    Id,
    Ind,
    IndArity,
    IndPack,
    Instance,
    Int,
    Level,
    List,
    Name,
    OneInd,
    PUniverses,
    RawLevel,
    RDecl,
    RecArg,
    RTree,
    Sort,
    SortContents,
    SortFam,
    Univ,
    Wfp,
};
use std::borrow::{Cow};
use std::convert::{TryFrom};
use std::iter::{self};
use std::option::{NoneError};
use std::sync::{Arc};

/// The different kinds of errors that may result of a malformed inductive
/// definition.
///
/// Errors related to inductive constructions
///
/// (and also additional errors generated by some subterms).
#[derive(Debug)]
pub enum InductiveError<'e, 'b, 'g> where 'b: 'e, 'g: 'b {
    NonPos(&'e mut Env<'b, 'g>, Constr, Constr),
    NotEnoughArgs(&'e mut Env<'b, 'g>, Constr, Constr),
    NotConstructor(&'e mut Env<'b, 'g>, Constr, Constr),
    NonPar(&'e mut Env<'b, 'g>, Constr, usize, Constr, Constr),
    SameNamesTypes(Id),
    SameNamesConstructors(Id),
    SameNamesOverlap(Vec<Id>),
    NotAnArity(Id),
    BadEntry,
    /// Inherited errors
    NotFound,
    Idx(IdxError),
    Anomaly(String),
    UniverseInconsistency(ConstraintType, Level, Level),
    UserError(String),
    Failure(String),
    NotEvaluableConst(ConstEvaluationResult),
    Red(Box<RedError>),
    Type(Box<TypeError<'e, 'b, 'g>>),
    NotConvertible,
    OutOfBounds,
}

#[derive(Debug)]
enum IllFormedInd {
    LocalNonPos(Int),
    LocalNotEnoughArgs(Int),
    LocalNotConstructor,
    LocalNonPar(usize, Int, Int),
    Idx(IdxError),
    Anomaly(String),
    Red(Box<RedError>),
    Failure(String),
    NotFound,
    UserError(String),
    OutOfBounds,
}

struct IEnv<'e, 'b, 'g> where 'b: 'e, 'g: 'b {
    /// [env] is the typing environment
    env: &'e Env<'b, 'g>,
    /// [extra] is the extension we are maintaining to the current environment's rel_context.
    extra: Vec<RDecl>,
    /// [n] is the dB of the last inductive type
    n: Int,
    /// [ntypes] is the number of inductive types in the definition
    ///   (i.e. range of inductives is [n; n+ntypes-1])
    ntypes: Int,
    /// [ra_env] is the list of recursive tree of each variable
    /// NOTE: Reversed from Ocaml!
    ra_env: Vec<(RecArg, Wfp)>,
}

type IllFormedResult<T> = Result<T, IllFormedInd>;

pub type InductiveResult<'e, 'b, 'g, T> = Result<T, Box<InductiveError<'e, 'b, 'g>>>;

impl ::std::convert::From<IdxError> for IllFormedInd {
    fn from(e: IdxError) -> Self {
        IllFormedInd::Idx(e)
    }
}

impl ::std::convert::From<RTreeError> for IllFormedInd {
    fn from(e: RTreeError) -> Self {
        match e {
            RTreeError::Idx(e) => e.into(),
            RTreeError::Failure(s) => IllFormedInd::Failure(s),
            RTreeError::OutOfBounds => IllFormedInd::OutOfBounds,
        }
    }
}

impl<'e, 'b, 'g> ::std::convert::From<SubstError> for IllFormedInd {
    fn from(e: SubstError) -> Self {
        match e {
            SubstError::Idx(e) => return e.into(),
            SubstError::NotFound => IllFormedInd::NotFound,
        }
    }
}

impl ::std::convert::From<Box<RedError>> for IllFormedInd
{
    fn from(e: Box<RedError>) -> Self {
        IllFormedInd::Red(e)
    }
}

impl<'e, 'b, 'g> ::std::convert::From<Box<SpecialRedError>> for IllFormedInd {
    fn from(e: Box<SpecialRedError>) -> Self {
        match *e {
            SpecialRedError::Anomaly(s) => IllFormedInd::Anomaly(s),
            SpecialRedError::Idx(e) => IllFormedInd::Idx(e),
            SpecialRedError::Red(e) => IllFormedInd::Red(e),
            SpecialRedError::UserError(s) => IllFormedInd::UserError(s),
        }
    }
}

impl<'e, 'b, 'g> ::std::convert::From<IndEvaluationError> for IllFormedInd {
    fn from(e: IndEvaluationError) -> Self {
        match e {
            IndEvaluationError::Subst(e) => e.into(),
            IndEvaluationError::SpecialRed(e) => e.into(),
        }
    }
}

impl<'e, 'b, 'g> ::std::convert::From<UnivError> for Box<InductiveError<'e, 'b, 'g>> {
    fn from(e: UnivError) -> Self {
        Box::new(match e {
            UnivError::Anomaly(s) => InductiveError::Anomaly(s),
        })
    }
}

impl<'e, 'b, 'g> ::std::convert::From<IdxError> for Box<InductiveError<'e, 'b, 'g>> {
    fn from(e: IdxError) -> Self {
        Box::new(InductiveError::Idx(e))
    }
}

impl<'e, 'b, 'g> ::std::convert::From<RTreeError> for Box<InductiveError<'e, 'b, 'g>> {
    fn from(e: RTreeError) -> Self {
        Box::new(match e {
            RTreeError::Idx(e) => return e.into(),
            RTreeError::Failure(s) => InductiveError::Failure(s),
            RTreeError::OutOfBounds => InductiveError::OutOfBounds,
        })
    }
}

impl<'e, 'b, 'g> ::std::convert::From<SubstError> for Box<InductiveError<'e, 'b, 'g>> {
    fn from(e: SubstError) -> Self {
        Box::new(match e {
            SubstError::Idx(e) => return e.into(),
            SubstError::NotFound => InductiveError::NotFound,
        })
    }
}

impl<'e, 'b, 'g> ::std::convert::From<EnvError> for Box<InductiveError<'e, 'b, 'g>> {
    fn from(e: EnvError) -> Self {
        Box::new(match e {
            EnvError::Anomaly(s) => InductiveError::Anomaly(s),
            EnvError::NotEvaluableConst(e) => InductiveError::NotEvaluableConst(e),
        })
    }
}

impl<'e, 'b, 'g> ::std::convert::From<DecomposeNError> for Box<InductiveError<'e, 'b, 'g>> {
    fn from(e: DecomposeNError) -> Self {
        Box::new(match e {
            DecomposeNError::UserError(s) => InductiveError::UserError(s),
        })
    }
}

impl<'e, 'b, 'g> ::std::convert::From<Box<UnivConstraintError>> for Box<InductiveError<'e, 'b, 'g>>
{
    fn from(e: Box<UnivConstraintError>) -> Self {
        Box::new(match *e {
            UnivConstraintError::UniverseInconsistency(d, ref l, ref r) =>
                InductiveError::UniverseInconsistency(d, l.clone(), r.clone()),
            UnivConstraintError::Anomaly(s) => InductiveError::Anomaly(s),
        })
    }
}

impl<'e, 'b, 'g> ::std::convert::From<Box<RedError>> for Box<InductiveError<'e, 'b, 'g>>
{
    fn from(e: Box<RedError>) -> Self {
        Box::new(match *e {
            RedError::Idx(e) => return e.into(),
            RedError::Env(e) => return e.into(),
            RedError::NotFound => InductiveError::NotFound,
        })
    }
}

impl<'e, 'b, 'g> ::std::convert::From<Box<ConvError>> for Box<InductiveError<'e, 'b, 'g>>
{
    fn from(e: Box<ConvError>) -> Self {
        Box::new(match *e {
            ConvError::Anomaly(s) => InductiveError::Anomaly(s),
            ConvError::Env(e) => return e.into(),
            ConvError::Idx(e) => return e.into(),
            ConvError::Univ(e) => return e.into(),
            ConvError::Red(e) => return e.into(),
            ConvError::NotConvertible => InductiveError::NotConvertible,
            ConvError::NotFound => InductiveError::NotFound,
        })
    }
}

impl<'e, 'b, 'g> ::std::convert::From<Box<CaseError<'e, 'b, 'g>>>
        for Box<InductiveError<'e, 'b, 'g>>
{
    fn from(e: Box<CaseError<'e, 'b, 'g>>) -> Self {
        Box::new(match *e {
            CaseError::Anomaly(s) => InductiveError::Anomaly(s),
            CaseError::Env(e) => return e.into(),
            CaseError::Idx(e) => return e.into(),
            CaseError::Univ(e) => return e.into(),
            CaseError::Red(e) => return e.into(),
            CaseError::NotFound => InductiveError::NotFound,
            CaseError::UserError(s) => InductiveError::UserError(s),
            CaseError::Subst(e) => return e.into(),
            CaseError::Type(e) => InductiveError::Type(e),
            CaseError::Failure(s) => InductiveError::Failure(s),
        })
    }
}

impl Constr {
    /// Same as noccur_between but may perform reductions.
    /// Could be refined more...
    ///
    /// NOTE: self must be typechecked beforehand!
    ///
    /// NOTE: mutates self in place!
    ///
    /// NOTE: Accepts an extra argument, extra, that gets appended to the env rel_context
    ///       prior to use.  Note that just as rel_context is reversed from the OCaml
    ///       implementation, so is extra.
    ///
    /// NOTE: Precondition: env; extra must be well-formed (FIXME: precise definition).
    fn weaker_noccur_between<'a, I>(&mut self, x: i64, nvars: i64, env: &'a Env,
                                    extra: I) -> RedResult<bool>
        where
            I: Iterator<Item=&'a RDecl>,
    {
        if self.noccur_between(x, nvars)? { return Ok(true) }
        self.whd_all(env, extra)?;
        Ok(self.noccur_between(x, nvars)?)
    }

    fn is_constructor_head(&self) -> bool {
        // TODO: consider using a version of this that doesn't allocate the vector.
        if let Constr::Rel(_) = *self.decompose_app().0 { true } else { false }
    }

    /// [mind_extract_params mie] extracts the params from an inductive types
    /// declaration, and checks that they are all present (and all the same)
    /// for all the given types.
    ///
    /// FIXME: The above description is wrong; it does no such thing!
    ///
    /// NOTE: The Vec<RDecl> is reversed from the Rctxt that would have been returned by OCaml.
    fn mind_extract_params(&self, n: usize) -> Result<(Vec<RDecl>, &Constr), DecomposeNError> {
        self.decompose_prod_n_assum(n)
    }

    fn failwith_non_pos(&self, n: Int, ntypes: Int) -> IllFormedResult<()> {
        let nmax = n.checked_add(ntypes).ok_or(IdxError::from(NoneError))?;
        // TODO: I know this is an error case but this seems like it's *really* inefficient if the
        // range is big... can we write a specialized function to find the offender immediately?
        for k in n..nmax {
            if !self.noccurn(k)? {
                // Subtraction is safe because n ≤ k and addition is safe because
                // k < nmax and nmax is a valid Int, so k - n < nmax too, hence
                // k - n + 1 ≤ nmax is a valid Int.
                return Err(IllFormedInd::LocalNonPos(k - n + 1))
            }
        }
        Ok(())
    }

    /// NOTE: Unlike the OCaml version, we don't have EVars available at all; instead of the
    /// checker's approach with the Evar, we use the kernel's approach with an implicit sort.
    fn lambda_implicit_lift(&self, n: Idx, tbl: &Huniv) -> IdxResult<Self> {
        // FIXME: This isn't properly Hconsed... but that's hopefully okay since this won't
        // actually be in the final expression.
        let implicit = Str(Arc::new(b"implicit".to_vec()));
        let raw_level = RawLevel::Level(0, List::Cons(ORef(Arc::new((implicit, List::Nil)))));
        // Hash is wrong... but it shouldn't matter if this never shows up.  Plus, we never
        // validate the hash anyway, so if this doesn't work because of the invalid hash, none of
        // our code that relies on the builtin hash is correct.  Same applies to the lack of
        // hashconsing for Dp (though, if it provides a false negative, it's probably something
        // where we can still say the checker is "correct" and we would have to fix this here).
        let level = Level { hash: 0, data: raw_level, };
        let univ = Univ::make(level, tbl)?;
        let implicit_sort = Constr::Sort(ORef(Arc::new(Sort::Type(univ))));
        Ok((0..u32::from(n)).fold(self.lift(n)?, |a, _|
            Constr::Lambda(ORef(Arc::new((Name::Anonymous, implicit_sort.clone(), a))))))
    }
}

impl<'b, 'g> Env<'b, 'g> where 'g: 'b {
    /// NOTE: Precondition: self is well-formed (FIXME: precise definition).
    ///
    /// NOTE: All entries in ctx1 must be typechecked beforehand in the context
    ///       of env extended with all the preceding elements of ctx1; all those in
    ///       ctx2 must be typechecked beforehand in the context of env extended
    ///       with all the preceding element of ctx2.
    ///
    /// NOTE: ctx1 and ctx2 should be in the reverse order of the OCaml implementation!
    ///
    /// NOTE: Postcondition: rev ctx1 and a prefix of rev ctx2 are convertible (the assumptions
    ///       have convertible types in the same contexts as above, the definitions have
    ///       both convertible types and bodies in those contexts, and len ctx1 ≤ len ctx2).
    fn conv_ctxt_prefix<'e>(&self, ctx1: &[RDecl],
                            ctx2: &[RDecl]) -> InductiveResult<'e, 'b, 'g, ()> {
        const ERR: &'static str = "not convertible contexts";
        if ctx1.len() > ctx2.len() { return Err(Box::new(InductiveError::Failure(ERR.into()))) }
        // TODO: See if there's a way to do this both efficiently, and in a way that makes it
        // clear that the iterator is actually going to cover all the old RDecls, without array
        // indexing (preferably).  Namely: is there any iterator that yields the old elements as
        // you traverse in one direction?
        // NOTE: The OCaml definition starts by reversing ctx1 and ctx2, but in our case they are
        // already reversed.
        for (i, (rctx1, rctx2)) in ctx1.into_iter().zip(ctx2).enumerate() {
            // NOTE: This slice cannot fail because
            //       0 ≤ i < ctx1.len().
            // This represents the old decls we've already covered, yielded in the same order in
            // which we covered them; this happens to be the correct order, because in the OCaml
            // version they would be pushed to the front of the environment in each iteration
            // (effectively reversing the list so far), and conv demands that the list
            // be reversed from what it would be in OCaml (which reverses it again).
            let extra = ctx1[0..i].into_iter();
            match (rctx1, rctx2) {
                (&RDecl::LocalAssum(_, ref ty1), &RDecl::LocalAssum(_, ref ty2)) => {
                    self.conv(ty1, ty2, extra)?;
                },
                (&RDecl::LocalDef(_, ref bd1, ref ty1), &RDecl::LocalDef(_, ref bd2, ref ty2)) => {
                    self.conv(ty1, ty2, extra.clone())?;
                    self.conv(bd1, bd2, extra)?;
                },
                _ => return Err(Box::new(InductiveError::Failure(ERR.into()))),
            }
        }
        return Ok(())
    }

    /// Typing the arities and constructor types
    ///
    /// NOTE: Returned Sort vector is in the *same* order as the OCaml version!
    ///
    /// NOTE: Precondition: self is well-formed (FIXME: precise definition).
    ///
    /// NOTE: Precondition: ∃ (ty' : constr) (s : sort), self ⊢ t : ty' ∧ self ⊨ ty' ≡ Sort s
    ///
    /// NOTE: Postcondition: t is positive (convertible to a type that is
    ///                      [modulo foralls and letins] a bound rel applied to some
    ///                      number of arguments).  The returned vector is the vector of sorts
    ///                      representing the sorts of the product types, in order.
    ///
    /// NOTE: t is mutated in-place!
    ///
    /// NOTE: We are not careful to maintain the environment correctly in the event of an error
    ///       (unless it's an error that explicitly returns the environment, in which case it's
    ///        the environment in which the error was supposed to be intended).  On success, the
    ///       environment should be unchanged.  Not PanicSafe in general (the environment is not
    ///       correctly preserved across panics).
    fn sorts_of_constr_args<'e>(&'e mut self, t: &mut Constr) ->
            CaseResult<'e, 'b, 'g, (&'e mut Self, Vec<Sort>)> {
        // TODO: This could probably be turned into an iterator to avoid allocating the Sort Vec.
        let mut sorts = Vec::new();
        // NOTE: We could probably avoid mutating rel_context if we really wanted to, but as
        //       long as infer_type has to do it anyway there's not much point.
        let rdecl_orig_len = self.rel_context.len();
        let mut env = self;
        loop {
            let env0 = env;
            t.whd_allnolet(env0, iter::empty())?;
            // Now we should just be composed of Prods, LetIns, and atoms.
            *t = match *t {
                Constr::Prod(ref o) => {
                    let (ref name, ref c1, ref c2) = **o;
                    // FIXME: Investigate why this is the only place in the entire checker (I
                    // believe) where we typecheck a Constr that doesn't have a global
                    // lifetime?  It seems rather fishy...
                    let (env1, varj) = env0.infer_type(c1)?;
                    env1.push_rel(RDecl::LocalAssum(name.clone(), c1.clone()));
                    sorts.push(varj);
                    env = env1;
                    c2.clone()
                },
                Constr::LetIn(ref o) => {
                    let (ref name, ref def, ref ty, ref c) = **o;
                    env0.push_rel(RDecl::LocalDef(name.clone(), def.clone(),
                                                 ORef(Arc::from(ty.clone()))));
                    env = env0;
                    c.clone()
                },
                _ if t.is_constructor_head() => {
                    // Make sure to unwind the rel_context on success.
                    // Note that we currently don't pop the rel if there was an error, even if it
                    // wasn't a TypeError that consumed the env.
                    env0.rel_context.truncate(rdecl_orig_len); return Ok((env0, sorts))
                },
                _ => {
                    const ERR: &'static str = "infos_and_sort: not a positive constructor";
                    return Err(Box::new(CaseError::Anomaly(ERR.into())))
                },
            }
        }
    }

    /// check information related to inductive arity
    ///
    /// NOTE: Precondition: self is well-formed (FIXME: precise definition).
    ///
    /// NOTE: Precondition: self is closed: self.rel_context should be empty!
    ///
    /// TODO: Checking arities in parallel is a no-brainer based on the above, but we need to
    ///       refactor a few things to make it work (globals needn't be mutable in env).
    ///
    /// NOTE: Precondition: rev params must be typechecked by check_ctxt in the context of self!
    ///
    /// NOTE: Precondition: (nparamdecls, nparamargs) = (rev params).nhyps()
    ///                     (so among other things, nparamargs ≤ nparamdecls and len params =
    ///                     nparamdecls).
    ///
    /// NOTE: params must be reversed from the Ocaml implementation!
    ///
    /// NOTE: Postcondition:
    ///
    /// env is extended with inds.len() RDecls, ars, with each ars[i] corresponding (in order
    /// from 0 to len inds - 1 in both arrays) to the "full" arity of inds[i].  The full arity
    /// is the result of calling local closure `check_arity` on inds[i].arity in the context
    /// of the original env and inds[i].arity_ctxt; the full arity is mk_arity ar_ctxt s, where
    /// s depends on the kind of arity (ignoring template arity, it is just mar.sort).
    ///
    /// Some things that are verified for each i s.t. 0 ≤ i < len inds:
    ///
    /// -  inds[i].nrealargs = nhyps inds[i].arity_ctxt - nparamargs and is safe to cast to usize
    /// -  inds[i].nrealdecls = len inds[i].arity_ctxt - nparamdecls and is safe to cast to usize
    /// -  if arity = RegularArity(mar):
    ///    -   ∃ s : sort, ⊢ mar.user_arity : Sort s
    ///    -   ⊨ mk_arity inds[i].arity_ctxt mar.sort ≡ ars[i] = mar.user_arity
    /// -  if arity = TemplateArity(par):
    ///    -   len par.param_levels ≤ len params
    ///    -   ⊨ ars[i] = mk_arity inds[i].arity_ctxt (Sort (Type par.level)) and
    ///          ∀ i, par.param_levels[i] = Some u →
    ///               params[len params - i - 1] = LocalAssum(_, ty) ∧
    ///               (rev params)[..i] ⊢ params[i].type : Sort [u]
    /// -  ∀ j : nat, 0 ≤ j < nparamdecls →
    ///    -   if (rev params)[j] = LocalAssum(_, ty), ∃ (ty1 : constr) (s1 : sort),
    ///        inds[i].arity_ctxt[j] = LocalAssum(_, ty1) ∧
    ///        (rev params)[..j] ⊢ ty1 : Sort s1 ∧
    ///        (rev params)[..j] ⊨ ty ≡ ty1
    ///    -   if (rev params)[j] = LocalDef(_, bd1, ty1), ∃ (j1 j2 : constr) (s1 s2 : sort),
    ///        inds[i].arity_ctxt[j] = LocalDef(_, bd2, ty2) ∧
    ///        (rev params)[..j] ⊢ bd2 : j1 ∧
    ///        (rev params)[..j] ⊢ j1 : Sort s1 ∧
    ///        (rev params)[..j] ⊢ ty2 : j2 ∧
    ///        (rev params)[..j] ⊢ j2 : Sort s2 ∧
    ///        (rev params)[..j] ⊨ j1 ≡ ty2 ∧
    ///        (rev params)[..j] ⊨ bd1 ≡ bd2
    ///        (rev params)[..j] ⊨ ty1 ≡ ty2
    ///
    ///    We refer to this last bullet as prefix compatibility: prefix params arity_ctxt means the
    ///    same as the above (plus the equivalent conditions for check_ctxt on params, but that
    ///    is done outside this function).
    ///
    /// Since we typechecked all the ars in a closed environment; this means that they also
    /// typecheck in every other correct environment, so their types are still correct
    /// when we push them onto the empty environment at the end.
    fn typecheck_arity<'e>(&'e mut self,
                           nparamdecls: usize, nparamargs: usize, params: &[RDecl],
                           inds: &[OneInd]) -> InductiveResult<'e, 'b, 'g, &'e mut Self> {
        // Precondition: arctxt must be typechecked by check_ctxt in the context of env.
        // Note: arctxt is reversed from the Ocaml version.
        // Postcondition:
        // -  if arity = RegularArity(mar):
        //    -   ∃ s : sort, ⊢ mar.user_arity : Sort s
        //    -   ⊨ mk_arity arctxt mar.sort ≡ mar.user_arity
        // -  if arity = TemplateArity(par):
        //    -   len par.param_levels ≤ len params
        //    -   ⊨ ar ≡ mk_arity arctxt (Sort (Type [u])) and
        //          ∀ i, par.param_levels[i] = Some u →
        //               params[len params - i - 1] = LocalAssum(_, ty) ∧
        //               rev params[i + 1..] ⊢ params[i].type : Sort [u]
        let check_arity = |env: &'e mut Env<'b, 'g>, arctxt: Vec<RDecl>,
                           a: &IndArity| -> InductiveResult<_> { match *a {
            IndArity::RegularArity(ref mar) => {
                let ar = &mar.user_arity;
                let (env, _) : (_, Sort) = env.infer_type(ar)?;
                // Now we know ar has type sort in the context of env.
                // We must re-reverse arctxt to get back to the OCaml version.
                let Ok(ty) = Constr::mk_arity(arctxt.into_iter().rev().map(Ok::<_, !>),
                                              mar.sort.clone(), |x| x);
                // arctxt typechecks in env, and sorts are (apparently) always well-typed, so
                // mar.sort is well-typed; so ty is well-typed, satisfying the prerequisites for
                // conv.
                // FIXME: Verify that sorts really don't require typechecking *at all*; that seems
                // fishy.
                env.conv(&ty, ar, iter::empty())?;
                // Now we know ty is convertible to ar (which means it is an arity).
                Ok((env, ar.clone()))
            },
            IndArity::TemplateArity(ref par) => {
                // params was typechecked in the style of check_ctxt, so we actually
                // have something stronger than the precondition; we do not reverse ctx, because
                // check_polymorphic_arity expects it to be in the usual order.
                env.check_polymorphic_arity(params, par)?;
                // Now we know par looks like an arity (it has only LocalAssums, no LocalDefs, and
                // ends in a sort (which always typechecks), and
                // len par.param_levels ≤ len params...
                // We must re-reverse arctxt to get back to the OCaml version.
                let Ok(ar) = Constr::mk_arity(arctxt.into_iter().rev().map(Ok::<_, !>),
                                              Sort::Type(par.level.clone()), |x| x);
                // ty is well-typed since it was a reasonable arity (each new declaration
                // typechecks in env extended with all the previous declarations).
                Ok((env, ar))
            },
        } };
        let mut env = self;
        // The extra rdecls used to store the assumptions corresponding to the mutually inductive
        // data types (in reverse order from the OCaml implementation); they will be pushed only
        // after they have been verified in the original environment.
        let mut ars = Vec::with_capacity(inds.len());
        // rev params typechecks in the context of env.
        for ind in inds {
            let env_ = env;
            let ar_ctxt = &ind.arity_ctxt;
            // TODO: expensive (but less clear we can help this one, since we need the clones, not
            // just the reverse).
            let ctx: Vec<_> = ar_ctxt.iter().cloned().collect();
            let (env_, ctx) = env_.check_ctxt(ctx)?;
            // Now we know that ctx = rev ar_ctxt typechecks in the context of env_.
            // And from before, we know rev params typechecks in the context of env.
            env_.conv_ctxt_prefix(params, &ctx)?;
            // Now we know that len params ≤ len ar_ctxt and a prefix of ar_ctxt is
            // convertible with params.
            // NOTE: Arities (with params) are typed-checked here
            let (env_, arity) = check_arity(env_, ctx, &ind.arity)?;
            // Now we know len par.param_levels ≤ len params ≤ len ar_ctxt
            // (if ind.arity = TemplateArity(par)) and in general this arity is "reasonable".
            let (nardecls, narargs) = ar_ctxt.nhyps();
            // Now we know (among other things) narargs ≤ nardecls and len ar_ctxt = nardecls
            // NOTE: Validating nrealargs.
            // We know narargs - nparamargs is non-negative because:
            //   rev params is convertible with some prefix of rev ar_ctxt, meaning that up to
            //   len params, they have the same number of LocalAssums and LocalDefs (actually, we
            //   know something much stronger, but that's all we need for the moment).  As a
            //   result, since narargs is based entirely on the count of LocalDefs in ar_ctxt, and
            //   nparamargs is based entirely on the count of LocalDefs in params, we know that
            //   there must be at least as many LocalDefs in ar_ctxt as there are in params (there
            //   may be more in ar_ctxt, but we don't need that for correctness here).
            let nrealargs = narargs - nparamargs;
            // Cast to isize from nrealargs is okay because Vecs always have at most
            // isize::MAX bytes, and RDecl has size ≥ 1 byte, so len ctx ≤ isize::MAX; therefore,
            // nrealargs = narargs - nparamargs ≤ narargs ≤
            // nardecls = len ar_ctxt = len ctx ≤ isize::MAX.
            // Casting to i64 from isize is okay because it is always okay
            // (FIXME: verify the last fact).  Note that after this, we also know that
            // ind.nrealargs is safe to cast to usize.
            if ind.nrealargs != nrealargs as i64 {
                const ERR : &'static str = "bad number of real inductive arguments";
                return Err(Box::new(InductiveError::Failure(ERR.into())))
            }
            // NOTE: Validating nrealdecls.
            // We know this is non-negative because (by conv_ctxt_prefix):
            //   nparamdecls = len params ≤ len ar_ctxt = nardecls, so 0 ≤ nardecls - nparamdecls.
            let nrealargs_ctxt = nardecls - nparamdecls;
            // Cast to isize from nrealargs_ctxt is okay because Vecs always have at most
            // isize::MAX bytes, and RDecl has size ≥ 1 byte, so len ctx ≤ isize::MAX; therefore,
            // nrealargs_ctxt = nardecls - nparamdecls ≤
            // nardecls = len ar_ctxt = len ctx ≤ isize::MAX.
            // Casting to i64 from isize is okay because it is always okay
            // (FIXME: verify the last fact).  Note that after this, we also know that
            // ind.nrealdecls is safe to cast to usize.
            if ind.nrealdecls != nrealargs_ctxt as i64 {
                const ERR: &'static str = "bad length of real inductive arguments signature";
                return Err(Box::new(InductiveError::Failure(ERR.into())));
            }
            // We do not need to generate the universe of full_arity; if later, after the
            // validation of the inductive definition, full_arity is used as an argument or subject
            // to cast, an upper universe will be generated.
            let id = &ind.typename;
            // NOTE: we defer pushing ars onto env until after we have verified all of them;
            // otherwise, we'd have to do things like lift params to preserve our invariants.
            ars.push(RDecl::LocalAssum(Name::Name(id.clone()), arity));
            env = env_;
        }
        // Now that we have verified that extending env with each inductive data type's full arity
        // is sane, and the various memoized values related to the arity are consistent both within
        // each OneInd and relative to its enclosing IndPack, we push all the ars into the
        // environment, in order of appearance.
        env.rel_context.extend(ars);
        Ok(env)
    }

    /// NOTE: params must be reversed from the Ocaml implementation!
    ///
    /// NOTE: Precondition: self is well-formed (FIXME: precise definition).
    ///
    /// NOTE: Precondition: self; params is well-formed (FIXME: precise definition).
    ///
    /// NOTE: Precondition: params is the result of calling check_ctxt in the empty rel_context.
    ///
    /// NOTE: Precondition:
    ///
    ///       ∀ c ∈ lc, ∃ (ty : constr) (s : sort),
    ///       self ⊢ c : ty ∧ self ⊢ ty ≡ Sort s ∧
    ///       params is convertible with a prefix of `decompose_prod_assum c`.
    ///
    /// NOTE: Re-returns params to the user on success.
    fn compute_elim_sorts<'e>(&'e mut self, params: Vec<RDecl>,
                              arity: &IndArity, lc: &[Constr]) ->
            CaseResult<'e, 'b, 'g, (&'e mut Self, Vec<RDecl>, &'static [SortFam])> {
        // extended_rel_list takes params in OCaml order, so we must reverse it here.
        let (inst, nparams) = extended_rel_list(params.iter().rev())?;
        // pus_rel_context takes params in reverse order, so we're fine.
        let rdecl_orig_len = self.rel_context.len();
        self.push_rel_context(params.into_iter());
        // TODO: Figure out a way to use iterators all the way through, and avoid allocating either
        // in here or in sorts_of_constr_args (then benchmark to see whether it's actually faster).
        let mut infos = Vec::with_capacity(lc.len());
        let mut env = self;
        for c in lc {
            let env_ = env;
            let mut c = if let Some(idx) = nparams {
                // NOTE: c was typechecked in env_ without params, so we have to make sure we lift
                // Constr to avoid capturing the parameters.  Thus:
                // [i] lift nparams c typechecks in env_; params (because c typechecks in env)
                // [ii] every term c in inst typechecks in env; params (because it is a rel
                //      referencing a parameter in the context).
                // [iii] Since params is convertible with a prefix of decompose_prod_assum c, it
                //       follows that repeatedly substituting the outer bound variable params[i] in
                //       c with a well-typed term inhabiting params[i] (the corresponding term in
                //       inst) preserves well-typedness; this satisfies the precondition for
                //       hnf_prod_applist.
                env_.hnf_prod_applist(c.lift(idx)?, inst.iter(), iter::empty())?
            } else { c.clone() }; // no parameters
            // c is well-typed in env_ and has any references to uniform parameters substituted in.
            // Also, its type is still a sort, since it was previously typed as a sort, and any
            // substitutions we made earlier preserved that property (we essentially just swapped
            // out one rel of a param type for another rel of that same param type).
            let (env_, sorts) = env_.sorts_of_constr_args(&mut c)?;
            // Now we know that the type concluded with a (well-typed) Rel applied to some things
            // in the context; it is positive.
            infos.push(sorts);
            env = env_;
        }
        let (small, unit) = small_unit(infos.iter());
        // Make sure to unwind the rel_context on success.
        // Note that we currently don't pop the rel if there was an error, even if it
        // wasn't a TypeError that consumed the env.
        let decls = env.rel_context.split_off(rdecl_orig_len);
        // We accept recursive unit types...
        // compute the max of the sorts of the products of the constructor type
        // TODO: Annoyingly, we could pass infos by-value but there's currently no optimization to
        // gain by doing this... universe merging should probably be overhauled.
        let level = Sort::max_inductive(infos.iter().flat_map(|x| x),
                                        &env.globals.univ_hcons_tbl)?;
        let s = arity.sort_of_ind();
        env.stratification.check_predicativity(&s, small, &level)?;
        Ok((env, decls, s.allowed_sorts(small, unit)))
    }

    /// NOTE: params must be reversed from the OCaml implementation!
    ///
    /// NOTE: Precondition: self is well-formed (FIXME: precise definition).
    ///
    /// NOTE: Precondition: self; params is well-formed (FIXME: precise definition).
    ///
    /// NOTE: Precondition: params is the result of calling check_ctxt in the empty rel_context.
    ///
    /// NOTE: Re-returns params to the user on success.
    pub fn typecheck_one_inductive<'e>(&'e mut self, params: Vec<RDecl>, mip: &OneInd) ->
            InductiveResult<'e, 'b, 'g, (&'e mut Self, Vec<RDecl>)> {
        // NOTE: mind_typename and mind_consnames not checked
        // NOTE: mind_reloc_tbl, mind_nb_constant, mind_nb_args not checked (VM)
        // NOTE: mind_arity_ctxt, mind_arity, mind_nrealargs DONE (typecheck_arity)
        // NOTE: mind_user_lc
        let env = mip.user_lc.iter().try_fold(self, |env, c| env.infer_type(c).map(|te| te.0))?;
        // NOTE: mind_nf_lc
        let env = mip.nf_lc.iter().try_fold(env, |env, c| env.infer_type(c).map(|te| te.0))?;
        if mip.user_lc.len() != mip.nf_lc.len() || mip.nf_lc.len() != mip.consnrealdecls.len() {
            // FIXME: Figure out whether OCaml version should check for this explicitly.
            const ERR : &'static str = "must have len nf_lc = len user_lc = len consnrealdecls";
            return Err(Box::new(InductiveError::Failure(ERR.into())))
        }
        for (nf, user) in mip.nf_lc.iter().zip(mip.user_lc.iter()) {
            env.conv(nf, user, iter::empty())?;
        }
        // NOTE: mind_consnrealdecls
        for (c, &n) in mip.nf_lc.iter().zip(mip.consnrealdecls.iter()) {
            let (ctx, _) = c.decompose_prod_assum();
            // NOTE: ctx is reversed from what it would be in the OCaml implementation.
            // FIXME: The Ocaml implementation does *not* do this and I don't understand how it can
            // avoid it; later, ctx is reduced after substituting in params, which seems like it
            // should only be valid if params is a prefix of the constructor type.
            // NOTE: params is valid in any compatible extension of the env in which is was
            // typechecked, and ctx typechecks in this env because it was decomposed from a term
            // that already typechecked in this env; both are reversed compared to the OCaml
            // implementation.
            env.conv_ctxt_prefix(&params, &ctx)?;
            // Now we know that len params ≤ len ctx and a prefix of ctx is
            // convertible with params.
            // We know this is non-negative because (by conv_ctxt_prefix):
            //   len params ≤ len ctx, so 0 ≤ len ctx - len params.
            let nrealdecls = ctx.len() - params.len();
            // Cast to isize from nrealdecls is okay because Vecs always have at most
            // isize::MAX bytes and RDecl has size ≥ 1 byte, so len ctx ≤ isize::MAX; therefore,
            // nrealdecls = len ctx - len params ≤ len ctx ≤ isize::MAX.
            // Casting to i64 from isize is okay because it is always okay
            // (FIXME: verify the last fact).  Note that after this, we also know that
            // any in-bounds mip.consnrealdecls[i] is safe to cast to usize.
            if n != nrealdecls as i64 {
                const ERR : &'static str = "bad number of real constructor arguments";
                return Err(Box::new(InductiveError::Failure(ERR.into())))
            }
        }
        // NOTE: mind_consnrealargs not checked
        // NOTE: mind_kelim: checked by positivity criterion ?
        let (env, params, sorts) = env.compute_elim_sorts(params, &mip.arity, &mip.nf_lc)?;
        if mip.kelim.iter().any(|&s| !sorts.iter().any(|&s_| s == s_)) {
            return Err(Box::new(InductiveError::Failure("elimination not allowed".into())))
        }
        // NOTE: mind_recargs: checked by positivity criterion
        Ok((env, params))
    }

    /// Positivity

    /// Conclusion of constructors: check the inductive type is called with
    /// the expected parameters
    ///
    /// NOTE: Precondition: self is well-formed (FIXME: precise definition).
    ///
    /// NOTE: Precondition: (nhyps, nparams) = rel_context_nhyps hyps.
    ///
    /// NOTE: Precondition: 0 ≤ nhyps < n.
    ///
    /// NOTE: Precondition: ∀ c ∈ lpar, c is typechecked in the context of self.
    ///
    /// NOTE: hyps is reversed from the OCaml version!
    ///
    /// NOTE: Postcondition:
    ///
    ///       Let gethyp hyps i be the number of LocalAssums at or before index i in hyps.  Then
    ///
    ///       nparams ≤ len largs ∧
    ///       (∀ i : nat, 0 ≤ i < nhyps → (rev hyps)[i] = LocalAssum _ →
    ///        largs[gethyp (rev hyps) i] ≡ Rel (n - nhyps + i)) ∧
    ///       (∀ i : nat, nparams ≤ i < len largs → !(occur_between n ntypes largs[i]))
    ///
    /// The idea is that the context consists of entries referring
    /// to the ntypes mutually inductive types in this block (from n + ntypes - 1 to n), followed
    /// by the types of n-1 constructor arguments of this constructor; the inductive type of the
    /// constructor is l, and hyps represents the types of uniform parameters to the inductive
    /// type.  We are checking the final return type of this constructor; it is the
    /// application of the inductive type Rel l to arguments largs.
    ///
    /// Our goal is to make sure this makes sense, by making sure the uniform parameters for the
    /// constructor's return type all match the uniform parameters of its enclosing inductive type,
    /// and the indices for the constructor's return type don't refer to any mutually inductive
    /// type in the same block (the latter case is not known to be safe).
    fn check_correct_par<'a, I>(&'a self, n: Int, ntypes: Int, nhyps: usize, nparams: usize,
                                hyps: &[RDecl], l: Int, largs: &[&Constr],
                                extra: I) -> IllFormedResult<()>
        where I: Iterator<Item=&'a RDecl> + Clone,
    {
        if largs.len() < nparams {
            return Err(IllFormedInd::LocalNotEnoughArgs(l))
        }
        // Now we know that largs includes enough uniform parameters for the inductive type.
        // Safe because 0 ≤ nparams ≤ largs.len()
        let (lpar, largs_) = largs.split_at(nparams);
        let mut k = nparams;
        // Safe because 0 ≤ nhyps < n, so n is a positive i64, meaning nhyps is safe to cast
        // to it since an unsigned usize in the nonnegative range of i64 is always safe to
        // cast to i64 (FIXME: verify this).  So 0 < n - nhyps as i64.
        let indexstart = n - nhyps as i64;
        // Loop invariant: 0 ≤ k ≤ nparams (true at beginning)
        // NOTE: hyps is backwards from the OCaml version, so we iterate backards.
        for (off, h) in hyps.iter().rev().enumerate() {
            // Safe because 0 ≤ off < nhyps and 0 < indexstart, so
            // 0 < indexstart ≤ indexstart + off < indexstart + nhyps →
            // 0 < n - nhyps ≤ n - nhyps + off < n - nhyps + nhyps = n,
            // The cast is safe because off is a positive integer < nhyps and nhyps is safe to cast
            // to i64.
            let index = indexstart + off as i64;
            // 0 < n - nhyps ≤ index < n
            if let RDecl::LocalAssum(..) = *h {
                // Observe that 0 < k ≤ nparams, because for every LocalAssum we've seen so far we
                // decremented k by 1, and nparams = rel_context_nhyps hyps is precisely the number
                // of LocalAssums in hyps; we didn't see this one yet, so k can't be 0 yet.
                // Since 0 < k ≤ nparams, 0 ≤ k - 1 < nparams, so decrementing is valid.
                k -= 1;
                // NOTE: lpar[k] is valid because len lpar = nparams and 0 ≤ k < nparams.
                let mut c = lpar[k].clone();
                // Safe because c is typechecked in self.
                c.whd_all(self, extra.clone())?;
                match c {
                    // We want to make sure that every uniform parameter in the constructor's
                    // return type is exactly the same as the uniform parameter of the inductive
                    // type (otherwise it might not be uniform).  Since we're going through the
                    // hypotheses in order from last added to first added, their rels steadily
                    // increase (index from n - nhyps to n - 1 inclusive), while we iterate
                    // arguments that correspond to parameters from right to left (k from
                    // nparams - 1 to 0 inclusive).
                    // So this argument is lpar[k], this uniform parameter has rel index, and if
                    // they're equal our uniform parameters are valid.
                    Constr::Rel(w) if w == index => {},
                    // NOTE: k + 1 is valid here because 0 ≤ k < nparams, so k + 1 ≤ nparams
                    // is a legal usize.  Observe that the k here is the same as what it is in the
                    // OCaml at this point, even though we've been iterating with k starting at
                    // nparams instead of nparams - 1, because we also subtracted 1 from k already
                    // here, while in the OCaml 1 only gets subtracted from k in the Rel branch.
                    _ => return Err(IllFormedInd::LocalNonPar(k + 1, index, l))
                }
            }
        }
        // Now we know the uniform parameters are correct.
        // We ensure that the nonuniform parameters are correct by making sure all rels do *not*
        // lie in [n, n + ntypes), i.e. the rels representing the mutually inductive types
        // themselves.  These are disjoint from the indices we considered before (from n - nhyps to
        // n  - 1).
        for arg_ in largs_ {
            if !arg_.noccur_between(n, ntypes)? {
                return Err(failwith_non_pos_iter(n, ntypes, largs_.into_iter().map(|&c| c)))
            }
        }
        return Ok(())
    }

    /// Arguments of constructor: check the number of recursive parameters nrecp.
    /// The first parameters which are constant in recursive arguments
    /// n is the current depth, nrecp is the maximum number of possible
    /// recursive parameters.
    ///
    /// NOTE: hyps is reversed from the OCaml version!
    ///
    /// NOTE: Precondition: 0 ≤ nparams ≤ len largs
    ///
    /// NOTE: Precondition: 0 ≤ len hyps < n (the nth is the current parameter being
    ///       investigated).
    ///
    /// NOTE: Precondition: ∀ c ∈ lpar, c is typechecked in the context of self.
    ///
    /// NOTE: Precondition: (_, nparams) = rel_context_nhyps hyps.
    ///
    /// NOTE: Postcondition:
    ///
    ///       Let gethyp hyps i be the number of LocalAssums at or before index i in hyps.  Then
    ///
    ///       nrecp ≤ nparams ∧
    ///       (∀ i : nat, 0 ≤ i < len hyps → hyps[i] = LocalAssum _ →
    ///        largs[gethyp hyps i] ≡ Rel (n - (i + 1)))
    ///
    /// The idea is that the context consists of entries referring
    /// to the ntypes mutually inductive types in this block (from n + ntypes - 1 to n), followed
    /// by the types of the first n-1 constructor arguments of this constructor; hyps represents
    /// the types of uniform parameters to the inductive type.  We are checking an application of
    /// some inductive type in the same mutually inductive block to arguments largs.
    ///
    /// Our goal is to make sure the parameters make sense, by making sure the uniform parameters
    /// for the inductive type all match the uniform parameters of its enclosing inductive type up
    /// to nrecp (these are the "ordinary", recursively uniform, parameters, as opposed to
    /// recursively non-uniform parameters, which may vary in different recursive invocations of
    /// the inductive data type).
    fn check_rec_par<'a, I>(&'a self, n: Int, nparams: usize, hyps: &[RDecl], nrecp: usize,
                            largs: &[&Constr], extra: I) -> IllFormedResult<()>
        where
            I: Iterator<Item=&'a RDecl> + Clone,
    {
        if nparams < nrecp {
            const ERR : &'static str =
                "number of recursive parameters cannot be greater than the number of parameters.";
            return Err(IllFormedInd::Failure(ERR.into()))
        }
        // Slice is safe because 0 ≤ nrecp ≤ nparams ≤ len largs.
        let lpar = &largs[0..nrecp];
        let mut lp = lpar.into_iter();
        // In the Ocaml version we reverse hyps before iterating; hyps is already reversed here.
        for (i, h) in hyps.into_iter().enumerate() {
            // 0 ≤ i < len hyps < n, so
            // 0 < i + 1 ≤ len hyps < n, and therefore 0 < n - (i + 1) < n (and the cast is okay,
            // since i + 1 < n and n is itself an i64).
            let index = n - (i + 1) as i64;
            if let RDecl::LocalDef(..) = *h { continue }
            // It's okay to run out of recursive parameters first, so we break in that case.
            let mut p = if let Some(&p) = lp.next() { p.clone() } else { break };
            p.whd_all(self, extra.clone())?;
            match p {
                // Each parameter passed to some recursive constructor call should match the
                // uniform parameters for the whole mutually inductive block.  To this end, we
                // iterate through the lpars and the uniform parameters, and make sure the rel
                // lpar[gethyp hyps i], the (gethyp hyps i + 1)th argument, corresponds to
                // Rel (n - (i + 1)), where Rel (n - 1) is the first hypothesis in the context,
                // so Rel (n - (i + 1)) represents the (gethyp hyps i + 1)th uniform parameter in
                // the context (observe that it is always at least 1, because 0 < n - (i + 1)).
                Constr::Rel(w) if w == index => {},
                _ => {
                    // FIXME: This error message seems wrong; isn't this a uniform parameter
                    // mismatch?
                    const ERR : &'static str = "bad number of recursive parameters";
                    return Err(IllFormedInd::Failure(ERR.into()))
                },
            }
        }
        Ok(())
    }
    /// NOTE: Precondition:
    ///
    /// ∀ i, 0 ≤ i < ntypes, ∃ (ar_ctxt : rel_context) (s : sort),
    /// env.rel_context[i] ≡ mk_arity ar_ctxt s ∧ prefix params ar_ctxt
    ///
    /// NOTE: params is reversed from OCaml!
    ///
    /// NOTE: Precondition: self must be well-formed (FIXME: precise definition).
    ///
    /// NOTE: Precondition: ntypes = len inds ∧ inds is based by a vector
    ///
    /// NOTE: Precondition: params is backed by a vector
    ///
    /// NOTE: Precondition: (lparams, nrealparams) = rel_context_nhyps params
    ///
    /// NOTE: Precondition: ∀ ind ∈ inds, ∀ c ∈ ind.nf_lc, ∃ s : sort, env ⊢ c : Sort s
    fn check_positivity<'e>(&'e mut self, mind: &Cst, ntypes: i64, lparams: usize,
                            nrealparams: usize, params: &[RDecl], nrecp: i64,
                            inds: &[OneInd]) -> InductiveResult<'e, 'b, 'g, &'e mut Self> {
        // The cast from j to i64 is valid because 0 ≤ j < len mk_rec_calls ntypes = ntypes,
        // which is itself a non-negative i64 (since it is equal to len inds).
        let mut rc = RTree::mk_rec_calls(ntypes).into_iter().enumerate().map(|(j, t)|
                  (RecArg::MRec(ORef(Arc::new(Ind { name: mind.clone(), pos: j as i64 }))), t))
            .collect::<Vec<_>>();

        // NOTE: ∀ i, 0 ≤ i < ntypes ↔ rc[i] = (MRec _, _).
        // NOTE: rc is reversed from the OCaml implementation.
        rc.extend(iter::repeat((RecArg::NoRec, RecArg::mk_norec())).take(lparams));
        // NOTE: ntypes can be safely cast to usize because it is equal to len inds, which is
        // itself a usize.
        let mut irecargs = Vec::with_capacity(ntypes as usize);
        // NOTE: lparams can be cast to i64 because: lparams = len params, params is a
        // vector, vectors have max size isize::MAX bytes, and RDecl has size ≥ 1 byte.
        // Casts from isize to i64 are always valid (FIXME: verify this).
        let n = (lparams as i64).checked_add(1).ok_or(IdxError::from(NoneError))?;
        // NOTE: lparams < n.
        // TODO: Maybe differentiate between nrecp negative and nrecp just too big... also observe
        // that the latter case can only happen on 32-bit or smaller systems.
        let nrecp = usize::try_from(nrecp).map_err(IdxError::from)?;
        let mut env = self;
        for (i, mip) in inds.into_iter().enumerate() {
            let env_ = env;
            let (env_, rc_, recarg) =
                // NOTE: 0 ≤ i < len inds = ntypes, inds is backed by a vector, vectors always have
                // at most isize::MAX bytes, and OneInd has ≥ 1 byte, so the cast from i to isize
                // is valid.  Casts from isize to i64 are always valid (FIXME: verify this).
                IEnv::check_positivity_one(env_, n, ntypes, rc, params,
                                           nrecp, Ind { name: mind.clone(), pos: i as i64 },
                                           &**mip.nf_lc, lparams, nrealparams)?;
            irecargs.push(recarg);
            env = env_;
            rc = rc_;
        }
        let wfp = RTree::mk_rec(&irecargs)?;
        // NOTE: len wfp = len irecargs by definition of mk_rec
        for (ind, wfpi) in inds.into_iter().zip(wfp) {
            ind.recargs.check_subtree(&wfpi)?;
        }
        Ok(env)
    }

    /// The following function does checks on inductive declarations.
    ///
    /// NOTE: Precondition: self is well-formed (FIXME: precise definition).
    ///
    /// NOTE: Precondition: self is closed: self.rel_context should be empty!
    ///
    /// NOTE: If the environment *is* returned in some way (either by error, or on success), it
    /// should be "correct" (in the sense that on success, it should be unchanged from before
    /// the call, and on error it should be the same as whatever the error was intended to be
    /// thrown with); but there are no guarantees if there's a panic or the environment wasn't
    /// explicitly returned (there was some other error).  Don't mark things containing Env
    /// PanicSafe!
    ///
    /// NOTE: The `log` parameter refers to the undo log used to track constraints and universes
    /// added to the environment's context.  The caller can consume it and undo all changes to the
    /// universe context by check_inductive (along with anything else already in the undo log).
    ///
    /// NOTE: Postcondition: env is extended with (kn, ind) and is still considered "well-formed."
    ///       rel_context is still empty.
    ///
    /// Well-formedness of the environment means, in this context, that all inductive types
    /// are well-formed, all universes have consistent constraints, and all local variables in
    /// rel_context are assigned a type whose type is a sort, that is well-typed with respect to
    /// all the previous local variables in rel-context and the rest of the environment.  "All
    /// inductive types are well-formed" is precisely what is addressed by check_inductive; every
    /// property that it enforces, is enforced in all well-formed inductive types in the
    /// environment.
    ///
    /// TODO: Explicitly state all of these properties (this mostly involves just union-ing
    /// together the guarantees from all the functions to which it calls out).
    pub fn check_inductive<'e>(&'e mut self, kn: &'g MutInd, mib: &'g IndPack,
                               log: &mut UndoLog<'g>
                              ) -> InductiveResult<'e, 'b, 'g, &'e mut Self> {
        // NOTE: check mind_constraints: should be consistent with env
        let ctxt = mib.universes.instantiate()?;
        self.stratification.push_context(false, &ctxt, log)?;
        // NOTE: check mind_record : TODO ? check #constructor = 1 ?
        // NOTE: check mind_finite : always OK
        // NOTE: check mind_ntypes
        // Cast to isize from mib.packets.len() is okay because Vec always has at most isize::MAX
        // bytes, and OneInd has size ≥ 1 byte.  Casting to i64 from isize is okay because it is
        // always okay (FIXME: verify the last fact).  Note that after this, we also know that
        // mib.ntypes is safe to cast to usize.
        if mib.packets.len() as i64 != mib.ntypes {
            const ERR : &'static str = "not the right number of packets";
            return Err(Box::new(InductiveError::UserError(ERR.into())))
        }
        // NOTE: check mind_params_ctxt
        let params = &mib.params_ctxt;
        // TODO: expensive (but less clear we can help this one, since we need the clones, not
        // just the reverse).
        let ctx: Vec<_> = params.iter().cloned().collect();
        let (env, ctx) = self.check_ctxt(ctx)?;
        // NOTE: check mind_nparams
        let (nparamdecls, nparamargs) = params.nhyps();
        // Cast to isize from nparamargs ≤ nparamdecls = params.len() = ctx.len() to isize is okay
        // because Vec always has at most isize::MAX bytes, and OneInd has size ≥ 1 byte.  Casting
        // to i64 from isize is okay because it is always okay (FIXME: verify the last fact).
        // Note that after this, we also know that mib.nparams is safe to cast to usize.
        if nparamargs as i64 != mib.nparams {
            // FIXME: this error message seems wrong...
            const ERR : &'static str = "number the right number of parameters";
            return Err(Box::new(InductiveError::UserError(ERR.into())))
        }
        // NOTE: mind_packets
        // - check arities
        let rdecl_orig_len = env.rel_context.len();
        let env = env.typecheck_arity(nparamdecls, nparamargs, &ctx, &mib.packets)?;
        // - check constructor types
        let (env, params) = mib.packets.iter().try_fold((env, ctx), |(env, params), mip|
            env.typecheck_one_inductive(params, mip))?;
        // - check mind_nparams_rec: positivity condition
        let env = env.check_positivity(kn, mib.ntypes, nparamdecls, nparamargs, &*params,
                                       mib.nparams_rec, &mib.packets)?;
        // NOTE: check mind_equiv...
        // FIXME: this doesn't seem to be happening?
        // Make sure to unwind the rel_context on success.
        // Note that we currently don't pop the rel if there was an error, even if it
        // wasn't a TypeError that consumed the env.
        // NOTE: We could really do a clear, since this was the empty context...
        env.rel_context.truncate(rdecl_orig_len);
        // Now we can add the inductive
        env.globals.add_mind(kn, mib)?;
        Ok(env)
    }
}

impl Sort {
    /// Prop and Set are small.
    fn is_small(&self) -> bool {
        if let Sort::Prop(_) = *self { true } else { false }
    }

    fn is_logic(&self) -> bool {
        if let Sort::Prop(SortContents::Null) = *self { true } else { false }
    }

    fn allowed_sorts(&self, is_small: bool, is_unit: bool) -> &'static [SortFam] {
        match self.family_of() {
            // Type: all elimination allowed
            SortFam::InType => SortFam::ALL_SORTS,
            // Small Set is predicative: all elimination allowed
            SortFam::InSet if is_small => SortFam::ALL_SORTS,
            // Large Set is necessarily impredicative: forbids large elimination
            SortFam::InSet => SortFam::SMALL_SORTS,
            // Unitary/empty Prop: elimination to all sorts are realizable
            // unless the type is large. If it is large, forbids large elimination
            // which otherwise allows simulating the inconsistent system Type:Type
            SortFam::InProp if is_unit =>
                if is_small { SortFam::ALL_SORTS } else { SortFam::SMALL_SORTS },
            // Other propositions: elimination only to Prop
            SortFam::InProp => SortFam::LOGICAL_SORTS,
        }
    }
}

impl<'g> Stratification<'g> {
    /// Allowed eliminations

    fn check_predicativity<'e, 'b>(&self, s: &Sort, small: bool,
                                   level: &Univ) -> CaseResult<'e, 'b, 'g, ()> {
        Ok(match (s, *self.engagement()) {
            (&Sort::Type(ref u), _) => {
                /*let u' = fresh_local_univ () in
                let cst =
                  merge_constraints (enforce_leq u u' empty_constraint)
                    (universes env) in */
                if !level.check_leq(u, self.universes())? { return Err(
                        Box::new(CaseError::Failure("impredicative Type inductive type".into())))
                }
            },
            (&Sort::Prop(SortContents::Pos), Engagement::ImpredicativeSet) => (),
            (&Sort::Prop(SortContents::Pos), _) => if !small {
                return Err(Box::new(CaseError::Failure("impredicative Set inductive type".into())))
            },
            (&Sort::Prop(SortContents::Null), _) => (),
        })
    }
}

impl IndArity {
    /// Returns the sort s.t. the full arity of some mip : OneInd is defined as:
    ///   mk_arity mip.arity_ctxt (Sort (sort_of_ind mip.arity))
    fn sort_of_ind(&self) -> Cow<Sort> {
        match *self {
            IndArity::RegularArity(ref mar) => Cow::Borrowed(&mar.sort),
            IndArity::TemplateArity(ref par) => Cow::Owned(Sort::Type(par.level.clone())),
        }
    }
}

impl SortFam {
    const ALL_SORTS : &'static [Self] = &[SortFam::InProp, SortFam::InSet, SortFam::InType];
    const SMALL_SORTS: &'static [Self] = &[SortFam::InProp, SortFam::InSet];
    const LOGICAL_SORTS : &'static [Self] = &[SortFam::InProp];
}

impl IllFormedInd {
    /// NOTE: Precondition: nbpar is safe to cast to usize
    fn explain_ind_err<'e, 'b, 'g>(self, ntyp: Int, env: &'e mut Env<'b, 'g>, nbpar: Int,
                                   c: &Constr) -> Box<InductiveError<'e, 'b, 'g>> {
        // Cast is safe by precondition.
        let (lpar, c_) = match c.mind_extract_params(nbpar as usize) {
            Ok(p) => p,
            Err(e) => return e.into(),
        };
        // NOTE: lpar reversed from OCaml, push_rel_context expects it to be reversed, so we're
        // fine.
        env.push_rel_context(lpar.into_iter());
        Box::new(match self {
            IllFormedInd::LocalNonPos(kt) =>
                if let Some(kt) = kt.checked_add(nbpar) {
                    InductiveError::NonPos(env, c_.clone(), Constr::Rel(kt))
                } else { return IdxError::from(NoneError).into() },
            IllFormedInd::LocalNotEnoughArgs(kt) =>
                if let Some(kt) = kt.checked_add(nbpar) {
                    InductiveError::NotEnoughArgs(env, c_.clone(), Constr::Rel(kt))
                } else { return IdxError::from(NoneError).into() },
            IllFormedInd::LocalNotConstructor =>
                if let Some(ntyp) = ntyp.checked_add(nbpar) {
                    InductiveError::NotConstructor(env, c_.clone(), Constr::Rel(ntyp))
                } else { return IdxError::from(NoneError).into() },
            IllFormedInd::LocalNonPar(n, i, l) =>
                if let Some(l) = l.checked_add(nbpar) {
                    InductiveError::NonPar(env, c_.clone(), n, Constr::Rel(i), Constr::Rel(l))
                } else { return IdxError::from(NoneError).into() },
            IllFormedInd::Idx(e) => return e.into(),
            IllFormedInd::Anomaly(e) => InductiveError::Anomaly(e),
            IllFormedInd::Red(e) => return e.into(),
            IllFormedInd::Failure(s) => InductiveError::Failure(s),
            IllFormedInd::NotFound => InductiveError::NotFound,
            IllFormedInd::UserError(s) => InductiveError::UserError(s),
            IllFormedInd::OutOfBounds => InductiveError::OutOfBounds,
        })
    }
}

impl<'g> Globals<'g> {
    /// This removes global parameters of the inductive types in lc (for
    /// nested inductive types only).
    ///
    /// NOTE: Precondition: 0 ≤ npars.
    ///
    /// NOTE: Precondition: ntyps = 1.
    ///
    /// FIXME: Hacky!  Slow!  Bad!
    ///
    /// Essentially we instantiate every recursive rel of the already-existing inductive type
    /// within itself with a dummy function taking n parameters that returns
    /// lift npars (Rel 1) ≡ Rel (npars + 1).  Since every instance of the function is applied to
    /// at least npars parameters (since npars is the number of recursive uniform parameters in the
    /// inductive type), this works as long as we also make sure to substitute the uniform
    /// parameters appropriately in whatever type is assigned to Rel 1 in the outer environment.
    fn abstract_mind_lc<'a>(&self, ntyps: Int, npars: Int,
                        lc: &'a [Constr]) -> IdxResult<Cow<'a, [Constr]>> {
        if let Some(npars) = NonZero::new(npars) {
            // NOTE: Only fails if npars is too big.
            let npars = Idx::new(npars)?;
            let make_abs: IdxResult<Vec<_>> = (1..=ntyps)
                .map(|i| Constr::Rel(i).lambda_implicit_lift(npars, &self.univ_hcons_tbl))
                .collect();
            let make_abs = make_abs?;
            lc.into_iter().map(|c| c.substl(&make_abs)).collect::<IdxResult<_>>().map(Cow::Owned)
        } else { Ok(Cow::Borrowed(lc)) }
    }
}

impl<'e, 'b, 'g> IEnv<'e, 'b, 'g> {
    /// NOTE: Precondition: self.env; self.extra is well-formed (FIXME: precise definition).
    ///
    /// NOTE: Precondition: ∃ s : sort, self.env; self.extra ⊢ a : Sort s
    fn push_var(&mut self, x: Name, a: Constr, ra: Wfp) -> IdxResult<()>
    {
        self.extra.push(RDecl::LocalAssum(x, a));
        // TODO: Use Idx here instead?
        self.n.checked_add(1).ok_or(IdxError::from(NoneError))?;
        self.ra_env.push((RecArg::NoRec, ra));
        Ok(())
    }

    /// NOTE: Precondition: mi is a valid inductive (and index) in self.env.globals.
    ///
    /// NOTE: Precondition: self.env; self.extra is well-formed (FIXME: precise definition).
    fn push_inductive(&mut self, mi: Ind, u: &Instance,
                      lpar: &[&Constr]) -> IndEvaluationResult<()> {
        let auxntyp = 1;
        let specif = match self.env.globals.lookup_mind_specif(&mi) {
            Ok(Some(specif)) => specif,
            Err(IndError::Idx(e)) => return Err(e.into()),
            _ => panic!("mi should have been a valid inductive (and index) in self.env.globals."),
        };
        let ty = self.env.type_of_inductive((specif, u), self.extra.iter())?;
        // Pseudo-reduction: substitute parameter types in mi with those in lpar.
        let appty = self.env.hnf_prod_applist(ty.into_owned(), lpar.into_iter().map(|&c| c),
                                              self.extra.iter())?;
        let decl = RDecl::LocalAssum(Name::Anonymous, appty);
        self.extra.push(decl);
        for &mut (_, ref mut t) in &mut self.ra_env {
            t.lift(1)?;
        }
        self.ra_env.push((RecArg::Imbr(ORef(Arc::new(mi))),
                          RTree::mk_rec_calls(1).pop().expect("vector has one element")));
        // New index of the inductive types
        self.n.checked_add(auxntyp).ok_or(IdxError::from(NoneError))?;
        Ok(())
    }

    /// NOTE: Precondition: c ≡ an iterated product with at least n args.
    ///
    /// NOTE: Precondition: self.env; self.extra is well-formed (FIXME: precise definition).
    ///
    /// NOTE: c must be typechecked beforehand in the context of self.env!
    fn decompose_prod(&mut self, mut n: usize, mut c: Constr) -> RedResult<Constr> {
        while n > 0 {
            c.whd_all(self.env, self.extra.iter())?;
            match c {
                Constr::Prod(o) => {
                    let (ref na, ref a, ref b) = *o;
                    self.push_var(na.clone(), a.clone(), RecArg::mk_norec())?;
                    c = b.clone();
                    // NOTE: n > 0 so this will definitely succeed.
                    n = n - 1;
                },
                _ => unreachable!("c ≡ an iterated product with at least n args")
            }
        }
        return Ok(c)
    }

    /// check the inductive types occur positively in [c]
    ///
    /// NOTE: hyps is reversed from OCaml
    ///
    /// NOTE: Precondition:
    ///
    /// ∀ i, 0 ≤ i < ntypes, ∃ (ar_ctxt : rel_context) (s : sort),
    /// self.env.rel_context[i] ≡ mk_arity ar_ctxt s ∧ prefix hyps ar_ctxt
    ///
    /// NOTE: Precondition:
    ///
    /// ∀ i, 0 ≤ i < ntypes ↔ self.ra_env[i] = (MRec _, _).
    ///
    /// NOTE: Precondition: lparams < self.n
    ///
    /// NOTE: Precondition: (lparams, nrealparams) = rel_context_nhyps hyps
    ///
    /// NOTE: Precondition: 0 ≤ i < ienv.ntypes
    ///
    /// NOTE: Precondition: hyps is backed by a vector
    ///
    /// NOTE: Precondition: self.env; self.extra must be well-formed (FIXME: precise definition).
    ///
    /// NOTE: Precondition: ∃ s : sort, self.env; self.extra ⊢ c : Sort s
    fn check_pos(&mut self, hyps: &[RDecl], nrecp: usize, i: Int, lparams: usize,
                 nrealparams: usize, mut c: Constr) -> IllFormedResult<Wfp> {
        let extra_len = self.extra.len();
        let ra_env_len = self.ra_env.len();
        let old_n = self.n;
        let ienv = self;
        // Loop invariant: lparams < ienv.n ∧ ∃ s : sort, ienv.env; ienv.extra ⊢ c : Sort s
        loop {
            c.whd_all(ienv.env, ienv.extra.iter())?;
            c = {
                let (x, mut largs) = c.decompose_app();
                // NOTE: largs is reversed from OCaml.
                // TODO: Just switch function calls to expect largs reversed
                largs.reverse();
                match *x {
                    Constr::Prod(ref o) => {
                        let (ref na, ref b, ref d) = **o;
                        // Since c typechecked, an application of a product must have an empty
                        // list.
                        assert!(largs.is_empty());
                        let mut b_ = b.clone();
                        if !b_.weaker_noccur_between(ienv.n, ienv.ntypes, ienv.env,
                                                     ienv.extra.iter())? {
                            return Err(failwith_non_pos_iter(ienv.n,  ienv.ntypes,
                                                             iter::once(b)));
                        } else {
                            // Since c typechecked, b_ must be of type sort.
                            ienv.push_var(na.clone(), b_, RecArg::mk_norec())?;
                            // NOTE: Loop invariant is preserved, since ∀ s : sort,
                            // ienv.env; ienv.extra ⊢ Π (na : b_). d : Sort s →
                            // ienv.env; ienv.extra, (na: b_) ⊢ d : Sort s
                            // (FIXME: verify, but seems reasonable)
                            // and n only increased by 1.
                            d.clone()
                        }
                    },
                    Constr::Rel(k) => {
                        // TODO: Maybe differentiate between nrecp negative and nrecp just too
                        // big... also observe that the latter case can only happen on 32-bit or
                        // smaller systems.
                        if k <= 0 { return Err(IdxError::from(NoneError).into()) }
                        // Now we know 0 < k.
                        // Recall: ra_env is backwards from OCaml
                        // len ra_env - 1 - (k - 1) = len ra_env - k
                        // NOTE: ienv.ra_env is a Vec, and vecs have at most isize::MAX bytes;
                        // (RecArg, Wfp) has size ≥ 1 byte, so len ienv.ra_env ≤ isize::MAX, hence
                        // it's safe to cast ienv.ra_env.len() to isize.  isize to i64 is valid
                        // because isize to i64 is always valid (FIXME: verify this last part).
                        let mut err = false;
                        if k <= ienv.ra_env.len() as i64 {
                            // NOTE: Casting k to usize is valid because k ≤ len ienv.ra_env, which
                            // is a usize.
                            // NOTE: 0 < k ≤ len ienv.ra_env →
                            //       0 ≤ len ienv.ra_env - k < len ienv.ra_env
                            let rarg = {
                                let (ref ra, ref rarg) =
                                    ienv.ra_env[ienv.ra_env.len() - k as usize];
                                if let RecArg::MRec(..) = *ra {
                                    // NOTE: if ra = MRec(..), then it must have been one of the
                                    // first ienv.ntypes arguments in ienv.ra_env, which means that
                                    // 0 ≤ len ra_env - k < ienv.ntypes.  We know that each of the
                                    // first ntypes rels in ienv.env; ienv.extra have some ar_ctxt
                                    // and sort s s.t. they can be typed mk_arity ar_ctxt s.  We
                                    // also know prefix hyps ar_ctxt.
                                    // Therefore, since c can be typed as a sort, we know that
                                    // Rel k must be fully applied to all its arguments, which
                                    // means it must be applied to at least
                                    // rel_context_nhyps ar_ctxt arguments, so
                                    // rel_context_nhyps hyps = nrealparams ≤
                                    // rel_context_nhyps ar_ctxt ≤ len largs.
                                    ienv.env.check_rec_par(ienv.n, nrealparams, &hyps, nrecp,
                                                           &largs, ienv.extra.iter())?;
                                }
                                for arg in &largs {
                                    if !arg.noccur_between(ienv.n, ienv.ntypes)? {
                                        err = true; break
                                    }
                                }
                                rarg.clone()
                            };
                            if err {
                                return Err(failwith_non_pos_iter(ienv.n, ienv.ntypes,
                                                                 largs.into_iter()))
                            }
                            // Unwind
                            ienv.extra.truncate(extra_len);
                            ienv.ra_env.truncate(ra_env_len);
                            ienv.n = old_n;
                            return Ok(rarg)
                        } else {
                            // Free variables are allowed and assigned NoRec
                            // NOTE: In the checker, this seems to catch a lot more things, but in
                            // the kernel only the array index is caught.. the kernel's behavior
                            // seems to make more sense.
                            ienv.extra.truncate(extra_len);
                            ienv.ra_env.truncate(ra_env_len);
                            ienv.n = old_n;
                            return Ok(RecArg::mk_norec())
                        }
                    },
                    Constr::Ind(ref ind_kn) => {
                        // If the inductive type being defined appears in a
                        // parameter, then we have an imbricated type
                        for arg in &largs {
                            if !arg.noccur_between(ienv.n, ienv.ntypes)? {
                                let res =
                                     ienv.check_positive_imbr(hyps, nrecp, i, lparams,
                                                              nrealparams, ind_kn, &largs)?;
                                ienv.extra.truncate(extra_len);
                                ienv.ra_env.truncate(ra_env_len);
                                ienv.n = old_n;
                                return Ok(res)
                            }
                        }
                        ienv.extra.truncate(extra_len);
                        ienv.ra_env.truncate(ra_env_len);
                        ienv.n = old_n;
                        return Ok(RecArg::mk_norec())
                    },
                    _ => { // err
                        let mut err = false;
                        for arg in iter::once(&x).chain(&largs) {
                            if !arg.noccur_between(ienv.n, ienv.ntypes)? { err = true; break }
                        }
                        if err { return Err(failwith_non_pos_iter(ienv.n, ienv.ntypes,
                                                                  iter::once(x).chain(largs))) }
                        ienv.extra.truncate(extra_len);
                        ienv.ra_env.truncate(ra_env_len);
                        ienv.n = old_n;
                        return Ok(RecArg::mk_norec())
                    },
                }
            }
        }
    }

    /// accesses to the environment are not factorised, but is it worth it?
    ///
    /// NOTE: hyps is reversed from OCaml
    ///
    /// NOTE: Precondition: ind_kn is a valid inductive (and index) in self.env.globals.
    ///
    /// NOTE: Precondition: ∃ s : sort, self.env; self.extra ⊢ (Ind ind_kn) largs : Sort s
    ///
    /// NOTE: Precondition: (lparams, nrealparams) = rel_context_nhyps hyps
    ///
    /// NOTE: Precondition: lparams < self.n
    ///
    /// NOTE: Precondition: 0 ≤ i < ienv.ntypes
    ///
    /// NOTE: Precondition: hyps is backed by a vector
    ///
    /// NOTE: Precondition: self.env; self.extra is well-formed (FIXME: precise definition).
    ///
    /// NOTE: Precondition:
    ///
    /// ∀ i, 0 ≤ i < ntypes, ∃ (ar_ctxt : rel_context) (s : sort),
    /// self.env.rel_context[i] ≡ mk_arity ar_ctxt s ∧ prefix hyps ar_ctxt
    ///
    /// NOTE: Precondition:
    ///
    /// ∀ i, 0 ≤ i < ntypes ↔ self.ra_env[i] = (MRec _, _).
    fn check_positive_imbr(&mut self, hyps: &[RDecl], nrecp: usize, i: Int, lparams: usize,
                           nrealparams: usize, ind_kn: &ORef<PUniverses<Ind>>,
                           largs: &[&Constr]) -> IllFormedResult<Wfp> {
        let (mib, mip) = match self.env.globals.lookup_mind_specif(&(**ind_kn).0) {
            Ok(Some(specif)) => specif,
            Err(IndError::Idx(e)) => return Err(e.into()),
            _ => panic!("mi should have been a valid inductive (and index) in self.env.globals."),
        };
        let auxnpar = mib.nparams_rec;
        // NOTE: auxnpar = mib.nparams_rec - mib.nparams is safe because self.env; self.extra is
        // well-formed, so mib.nparams_rec ≤ mib.nparams, therefore 0 ≤ nonrecpar.
        let nonrecpar = mib.nparams - auxnpar;
        // FIXME: This shouldn't actually be able to happen, right?
        // NOTE: auxnpar can be cast to usize because auxnpar = mib.nparams, and mib,mip is a
        // well-formed inductive type.
        if largs.len() < auxnpar as usize {
            return Err(IllFormedInd::LocalNonPos(self.n))
        }
        // NOTE: auxlargs can be cast to usize because self.env; self.extra is well-formed.
        // NOTE: Because (Ind ind_kn) largs can be typed as a sort, (Ind ind_kn) largs) is fully
        // applied to ind_kn's parameters and indices.  Because the environment is well-formed,
        // mib.nparams_rec ≤ mib.nparams, and prefix mib.params mip.arity_ctxt, so
        // auxnpar = mib.nparams_rec ≤ nparams - = rel_context_nhyps mib.params ≤
        // rel_contxt_nhyps mib.ar_ctxt ≤ len largs, Therefore, 0 ≤ auxnpar ≤ len largs, so
        // split_at is safe.
        let (lpar, auxlargs) = largs.split_at(auxnpar as usize);
        // If the inductive appears in the args (non params) then the definition is not positive.
        for arg in auxlargs {
            if !arg.noccur_between(self.n, self.ntypes)? {
                return Err(IllFormedInd::LocalNonPos(self.n))
            }
        }
        // We do not deal with imbricated mutual inductive types
        let auxntyp = mib.ntypes;
        if auxntyp != 1 {
            return Err(IllFormedInd::LocalNonPos(self.n))
        }
        // The nested inductive type with parameters removed
        // NOTE: We know 0 ≤ auxnpar, and auxntyp = 1; imp.nf_lc typecheck in the empty context
        // and therefore typecheck in self.env; self.extra.  Then the resulting constructor types
        // auxlvect should still typecheck in self.env; self.extra after extending that
        // environment with a rel representing (Ind (ind_kn) lpar) (the new rel is typed as
        // the inductive type with its recursively uniform parameters applied, and the new
        // constructor types have those uniform parameters removed).
        let auxlcvect = self.env.globals.abstract_mind_lc(auxntyp, auxnpar, &mip.nf_lc)?;
        // Extends the environment with a variable corresponding to the inductive def, to complete
        // the above.
        self.push_inductive((**ind_kn).0.clone(), &ind_kn.1, lpar)?;
        let extra_len = self.extra.len();
        let ra_env_len = self.ra_env.len();
        let old_n = self.n;
        // Parameters expressed in env'; we have to lift all the largs (the instantiated arguments
        // that aren't recursively uniform parameters of ind_kn) by 1 in order to make them still
        // typecheck.
        // NOTE: Idx::ONE = auxntyp.
        let lpar_: Result<Vec<_>, _> = lpar.into_iter().map(|c| c.lift(Idx::ONE)).collect();
        let lpar_ = lpar_?;
        let mut irecargs = Vec::with_capacity(auxlcvect.len());
        // fails if the inductive type occurs non positively
        // with recursive parameters substituted
        let ienv = self;
        for c in auxlcvect.into_iter() {
            // NOTE: Because of the work we did before, c and lpar_ are all still well-typed in the
            // new env.
            let c_ = ienv.env.hnf_prod_applist(c.clone(), lpar_.iter(), ienv.extra.iter())?;
            // skip non-recursive parameters
            // NOTE: We know c_ is an iterated product of at least nonrecpar parameters because
            // nonrecpar = mib.nparams_rec = mib.nparams, and we chopped off mib.nparams when we
            // called abstract_mind_lc.
            // NOTE: We know nonrecpar is a usize because 0 ≤ nonrecpar ≤ mib.nparams, which can be
            // safely cast to a usize because mib,mip is a well-formed inductive type.
            let c_ = ienv.decompose_prod(nonrecpar as usize, c_)?;
            // NOTE: Preconditions are still satisfied after getting rid of the rest of the
            // parameters, as decompose_prod just applies the product typing rule.
            let recarg = ienv.check_constructors(hyps, nrecp, i, lparams, nrealparams, false, c_)?;
            // remember to truncate at loop end
            ienv.extra.truncate(extra_len);
            ienv.ra_env.truncate(ra_env_len);
            ienv.n = old_n;
            irecargs.push(recarg);
        }
        // Truncate and unlift after the push_inductive.
        let (imbr, _) = ienv.ra_env.pop().expect("pushed on the recursive argument before");
        ienv.extra.pop().expect("pushed on the recursive argument before");
        ienv.n = old_n;
        // FIXME: If something breaks, look here first; not sure if negative lifts acually work
        // even on RTrees.  But the idea is to undo the lift of ra_env that happened previously.
        for &mut (_, ref mut t) in &mut ienv.ra_env {
            t.lift(-1)?;
        }
        Ok(RTree::mk_rec(&[RecArg::mk_paths(imbr, irecargs)])?
           .pop().expect("vector has one element"))
    }

    /// check the inductive types occur positively in the products of C, if
    /// check_head=true, also check the head corresponds to a constructor of
    /// the ith type
    ///
    /// NOTE: hyps is reversed from OCaml
    ///
    /// NOTE: Precondition: self.env; self.extra must be well-formed (FIXME: precise definition).
    ///
    /// NOTE: Precondition: (lparams, nrealparams) = rel_context_nhyps hyps
    ///
    /// NOTE: Precondition: hyps is backed by a vector
    ///
    /// NOTE: Precondition: lparams < self.n
    ///
    /// NOTE: Precondition: 0 ≤ i < ienv.ntypes
    ///
    /// NOTE: Precondition: ∃ s : sort, self.env; self.extra ⊢ c : Sort s
    ///
    /// NOTE: Precondition:
    ///
    /// ∀ i, 0 ≤ i < ntypes, ∃ (ar_ctxt : rel_context) (s : sort),
    /// self.env.rel_context[i] ≡ mk_arity ar_ctxt s ∧ prefix hyps ar_ctxt
    ///
    /// NOTE: Precondition:
    ///
    /// ∀ i, 0 ≤ i < ntypes ↔ self.ra_env[i] = (MRec _, _).
    fn check_constructors(&mut self, hyps: &[RDecl], nrecp: usize, i: Int,
                          lparams: usize, nrealparams: usize, check_head: bool,
                          mut c: Constr) -> IllFormedResult<Vec<Wfp>> {
        let mut lrec = Vec::new();
        let extra_len = self.extra.len();
        let ra_env_len = self.ra_env.len();
        let old_n = self.n;
        let ienv = self;
        // Loop invariant: lparams < ienv.n ∧  ∃ s : sort, ienv.env; ienv.extra ⊢ c : Sort s
        loop {
            c.whd_all(ienv.env, ienv.extra.iter())?;
            c = {
                let (x, mut largs) = c.decompose_app();
                // NOTE: largs is reversed from OCaml.
                // TODO: Just switch function calls to expect largs reversed
                largs.reverse();
                match *x {
                    Constr::Prod(ref o) => {
                        let (ref na, ref b, ref d) = **o;
                        // Since c typechecked, an application of a product must have an empty
                        // list.
                        assert!(largs.is_empty());
                        // Since c typechecked, b must be of type sort.
                        let recarg = ienv.check_pos(hyps, nrecp, i, lparams,
                                                    nrealparams, b.clone())?;
                        ienv.push_var(na.clone(), b.clone(), RecArg::mk_norec())?;
                        lrec.push(recarg);
                        // NOTE: Loop invariant is preserved, since ∀ s : sort,
                        // ienv.env; ienv.extra ⊢ Π (na : b). d : Sort s →
                        // ienv.env; ienv.extra, (na: b) ⊢ d : Sort s
                        // (FIXME: verify, but seems reasonable)
                        // and n only increased by 1.
                        d.clone()
                    },
                    ref hd => {
                        if check_head {
                            let n_ = ienv.n.checked_add(ienv.ntypes).ok_or(IdxError::from(NoneError))?;
                            match *hd {
                                // NOTE: 0 ≤ lparams < ienv.n, and 0 ≤ i < ienv.ntypes →
                                // 0 ≤ ienv.ntypes - i - 1, so
                                // 0 ≤ lparams < ienv.n ≤ ienv.n + ienv.ntypes - i - 1 = n_ - i - 1
                                // ≤ ienv.n + ienv.ntypes - (0 - 1) - 1 = ienv.n + ienv.nypes →
                                // 0 ≤ lparams < ienv.n, and 1 ≤ n_ - i - 1 ≤ ienv.n + ienv.ntypes
                                Constr::Rel(j) if j == n_ - i - 1 => {
                                    // NOTE: 0 ≤ i < ntypes, so ienv.ntypes - i is in bounds.
                                    ienv.env.check_correct_par(ienv.n, ienv.ntypes, lparams,
                                                               nrealparams, hyps, ienv.ntypes - i,
                                                               &largs, ienv.extra.iter())?
                                },
                                _ => {
                                    return Err(IllFormedInd::LocalNotConstructor)
                                }
                            }
                        } else {
                            for arg in largs {
                                if !arg.noccur_between(ienv.n, ienv.ntypes)? {
                                    return Err(IllFormedInd::LocalNonPos(ienv.n))
                                }
                            }
                        }
                        // Make sure to unwind the context.
                        ienv.n = old_n;
                        ienv.ra_env.truncate(ra_env_len);
                        ienv.extra.truncate(extra_len);
                        // NOTE: In OCaml, we List.reverse here, but here we already reversed it
                        // earlier.
                        return Ok(lrec)
                    },
                }
            };
        }
    }

    /// The recursive function that checks positivity and builds the list
    /// of recursive arguments
    ///
    /// NOTE: hyps is reversed from OCaml
    ///
    /// NOTE: Precondition: env must be well-formed (FIXME: precise definition).
    ///
    /// NOTE: Precondition: 0 ≤ ind.pos < ienv.ntypes
    ///
    /// NOTE: Precondition: (lparams, nrealparams) = rel_context_nhyps hyps
    ///
    /// NOTE: Precondition: lparams < n
    ///
    /// NOTE: Precondition: hyps is backed by a vector
    ///
    /// NOTE: Precondition:
    ///
    /// ∀ i, 0 ≤ i < ntypes, ∃ (ar_ctxt : rel_context) (s : sort),
    /// env.rel_context[i] ≡ mk_arity ar_ctxt s ∧ prefix hyps ar_ctxt
    ///
    /// NOTE: Precondition:
    ///
    /// ∀ i, 0 ≤ i < ntypes ↔ ra_env[i] = (MRec _, _).
    ///
    /// NOTE: Precondition: ∀ c ∈ indlc, ∃ s : sort, env ⊢ c : Sort s
    fn check_positivity_one(env: &'e mut Env<'b, 'g>, n: Int, ntypes: Int,
                            ra_env: Vec<(RecArg, Wfp)>, hyps: &[RDecl],
                            nrecp: usize, ind: Ind, indlc: &[Constr], lparams: usize,
                            nrealparams: usize) ->
            InductiveResult<'e, 'b, 'g, (&'e mut Env<'b, 'g>, Vec<(RecArg, Wfp)>, Wfp)> {
        let mut res = Ok(());
        let mut irecargs = Vec::with_capacity(indlc.len());
        let ra_env = {
            let mut ienv = IEnv { env: env, extra: Vec::new(), n: n, ntypes: ntypes,
                                  ra_env: ra_env };
            for c in indlc {
                let (_, rawc) = c.mind_extract_params(lparams)?;
                match ienv.check_constructors(hyps, nrecp, ind.pos, lparams, nrealparams,
                                                           true, rawc.clone()) {
                    Ok(recargs) => { irecargs.push(recargs) },
                    // NOTE: lparams can be cast to i64 because it is the same as len hyps, and
                    // hyps is backed by a vector; vectors have size at most isize::MAX bytes,
                    // and RDecl takes up more than one byte, so lparams can be cast to isize.
                    // isize can always be cast to i64, so we're done (FIXME: verify this last
                    // part).
                    Err(err) => { res = Err((c, err)); break; },
                }
            }
            ienv.ra_env
        };
        if let Err((c, err)) = res {
            // NOTE: 0 ≤ ind.pos < ntypes, so ntypes - ind.pos is in bounds.
            Err(err.explain_ind_err((ntypes - ind.pos), env, lparams as i64, c))
        } else {
            Ok((env, ra_env, RecArg::mk_paths(RecArg::MRec(ORef(Arc::new(ind))), irecargs)))
        }
    }
}

impl Wfp {
    fn check_subtree<'e, 'b, 'g>(&self, t2: &Self) -> InductiveResult<'e, 'b, 'g, ()> {
        if !self.equiv(t2, RecArg::eq, |l1, l2| if let RecArg::NoRec = *l1 { true }
                                                else { l1.eq(l2) })? {
            return Err(Box::new(InductiveError::Failure("bad recursive trees".into())))
        }
        // FIXME: What is the below about?
        // if t1=t2 then () else msg_warning (str"TODO: check recursive positions")
        Ok(())
    }
}

/// [infos] is a sequence of pair [islogic,issmall] for each type in
/// the product of a constructor or arity
fn is_small_constr<'a, I>(mut infos: I) -> bool
    where
        I: Iterator<Item=&'a Sort>,
{
    infos.all(Sort::is_small)
}

fn is_logic_constr<'a, I>(mut infos: I) -> bool
    where
        I: Iterator<Item=&'a Sort>,
{
    infos.all(Sort::is_logic)
}

/// An inductive definition is a "unit" if it has only one constructor
/// and that all arguments expected by this constructor are
/// logical, this is the case for equality, conjunction of logical properties
fn is_unit<'a, I>(mut constrsinfos: I) -> bool
    where
        I: Iterator,
        I::Item: IntoIterator<Item=&'a Sort>,
{
    if let Some(constrinfos) = constrsinfos.next() {
        if let None = constrsinfos.next() { false }
        else { // One info = One constructor
            is_logic_constr(constrinfos.into_iter())
        }
    } else { true } // type without constructors
}

fn small_unit<'a, I>(constrsinfos: I) -> (bool, bool)
    where
        I: Iterator + Clone,
        I::Item: IntoIterator<Item=&'a Sort>,
{
    let is_small = constrsinfos.clone().map(IntoIterator::into_iter).all(is_small_constr);
    let is_unit = is_unit(constrsinfos);
    (is_small, is_unit)
}

fn failwith_non_pos_iter<'a, I>(n: Int, ntypes: Int, mut v: I) -> IllFormedInd
    where
        I: Iterator<Item=&'a Constr>,
{
    const ERR : &'static str = "failwith_non_pos_iter: some k in [n;n+ntypes-1] should occur";
    if let Err(e) = v.try_fold((), |_, c| c.failwith_non_pos(n, ntypes)) { e }
    else { IllFormedInd::Anomaly(ERR.into()) }
}
